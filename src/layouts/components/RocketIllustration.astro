---
import heroComputer from '../../images/pchero.svg';
import heroRocket from '../../images/rockethero.svg';
import heroBase from '../../images/basehero.svg';
import heroSmoke from '../../images/smokehero.svg';

---

<section class="hero-illustration">
  <img
    src={heroComputer.src}
    alt='Ilustraci√≥n de un ordenador port√°til con una ventana web abierta y un bot√≥n de Click Here, acompa√±ado de un      cohete
    despegando.'
    class="hero-illustration__computer"
        
  />
  <img
    src={heroRocket.src}
    alt='Ilustraci√≥n de un ordenador port√°til con una ventana web abierta y un bot√≥n de Click Here, acompa√±ado de un      cohete
    despegando.'
    class="hero-illustration__rocket"
  />
  <img
    src={heroSmoke.src}
    alt='Ilustraci√≥n de un ordenador port√°til con una ventana web abierta y un bot√≥n de Click Here, acompa√±ado de un      cohete
    despegando.'
    class="hero-illustration__smoke"
  />

  <img
    src={heroBase.src}
    alt='Ilustraci√≥n de un ordenador port√°til con una ventana web abierta y un bot√≥n de Click Here, acompa√±ado de un      cohete
    despegando.'
    class="hero-illustration__base"
  />

</section>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const rocket = document.querySelector(".hero-illustration__rocket");
    const computer = document.querySelector(".hero-illustration__computer"); // Nuevo
    const container = document.querySelector(".hero-illustration");
    const isMobile = window.matchMedia("(max-width: 768px)").matches;

    if (!rocket || !container || !computer) return; // Salir si no se encuentran elementos

    // Funci√≥n que resetea el cohete a su posici√≥n inicial
    const resetRocket = () => {
      // Elimina la clase 'launch' o cualquier estilo de animaci√≥n
      rocket.classList.remove("launch");
      
      // Opcional, forzar un reseteo de estilos inline si fuera necesario, aunque 'remove' deber√≠a bastar
      // rocket.style.transform = '';
      // rocket.style.opacity = ''; 
    };

    /* ========================================================== */
    /* üöÄ L√ìGICA M√ìVIL (Animaci√≥n √önica al entrar en la vista) */
    /* ========================================================== */
    if (isMobile) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            rocket.classList.add("launch");
            observer.unobserve(container); // ‚úÖ Solo una vez
          }
        });
      }, { threshold: 0.3 });
      
      observer.observe(container);

      // Evento para forzar el RESET despu√©s de que termina la animaci√≥n de subida
      rocket.addEventListener('animationend', resetRocket, { once: true }); 
      // Usamos 'once: true' para que solo se ejecute la primera vez que la animaci√≥n termina.
    }

    /* ========================================================== */
    /* üöÄ L√ìGICA ESCRITORIO (Hover repetible) */
    /* ========================================================== */
    if (!isMobile) {
      // 1. Hover para subir y desaparecer
      computer.addEventListener('mouseenter', () => {
        // A√±ade la clase que activa la animaci√≥n de subida (rocketLaunchAndDisappear)
        rocket.classList.add("launch");
        // Nota: El CSS es el que hace que suba con 'forwards'.
      });

      // 2. Mouseleave para resetear INSTANT√ÅNEAMENTE
      computer.addEventListener('mouseleave', () => {
        // Retrasa un poco el reseteo para que la animaci√≥n tenga tiempo de terminar
        setTimeout(() => {
          resetRocket(); 
        }, 10); // Un retraso muy peque√±o (10ms)
      });
    }
  });
</script>